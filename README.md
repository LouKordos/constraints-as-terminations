# Constraints As Terminations (CaT)

[Website](https://constraints-as-terminations.github.io) | [Technical Paper](https://arxiv.org/abs/2403.18765) | [Videos](https://www.youtube.com/watch?v=crWoYTb8QvU)

![](assets/teaser.png)

## About this repository

This repository contains an Isaaclab implementation of the article **CaT: Constraints as Terminations for Legged Locomotion Reinforcement Learning** by Elliot Chane-Sane\*, Pierre-Alexandre Leziart\*, Thomas Flayols, Olivier Stasse, Philippe Souères, and Nicolas Mansard.

This implementation was built by Constant Roux and Maciej Stępień.

This paper has been accepted for the 2024 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS 2024).

This code relies on the [CleanRL](https://github.com/vwxyzjn/cleanrl) library and [IsaacLab](https://isaac-sim.github.io/IsaacLab/v1.4.1/index.html) (version 1.4.1).

Implementation of the constraints manager and modification of the environment can be found in the [CaT directory](exts/cat_envs/cat_envs/tasks/utils/cat/). The modified PPO implementation can be found in the [CleanRL directory](exts/cat_envs/cat_envs/tasks/utils/cleanrl/).

`ConstraintsManager` follows the manager-based Isaac Lab approach, allowing easy integration just like other managers. For a full example, check out [cat_flat_env_cfg.py](exts/cat_envs/cat_envs/tasks/locomotion/velocity/config/solo12/cat_flat_env_cfg.py).

```python
@configclass
class ConstraintsCfg:
    # Safety Soft Constraints
    joint_torque = ConstraintTerm(
        func=constraints.joint_torque,
        max_p=0.25,
        params={"limit": 3.0, "names": [".*_HAA", ".*_HFE", ".*_KFE"]},
    )
    # Safety Hard Constraints
    contact = ConstraintTerm(
        func=constraints.contact,
        max_p=1.0,
        params={"names": ["base_link", ".*_UPPER_LEG"]},
    )
```


## Running CaT (fork, follow this)

### Training and Isaac Lab Simulation

Training and isaac lab related tasks were tested without docker, by using `create-isaac-lab-env-uv.py`. To use a more recent version, change `KNOWN_GOOD_COMMIT` in the script, then run. This will create a venv and print steps to activate and train. Check the slurm config and the `justfile` for available commands, as well as the `scripts` directory.

### Sim2Real

For deploying on real robot, the `sim2real` directory is relevant. It uses docker containers for ROS and you should build and run using `build-and-run.sh`. Check the options inside the script. NOTE: This script is responsible for building both the docker container and the actual code base, so you simply run it after cloning once and then inside the container again.

For communication with Go2, you need to `export ROS_DOMAIN_ID=0` and source the workspace (as the docker bashrc already tells you to). Also set up your network and ensure you can ping the robot: (https://support.unitree.com/home/en/developer/Quick_start)[https://support.unitree.com/home/en/developer/Quick_start].

You should be able to run the code on either your workstation connected to the Go2 via Ethernet, or the Go2 itself. However, it is recommended to run as much as possible on the actual robot and only visualizations or plotting on the workstation for latency and EMI reasons. **Ensure the time between Go2 and your workstation are synced, which can be tricky without an internet connection on the Go2 Jetson.** As a helper, you can use `ssh-time-sync.sh`.

DO NOT SOURCE THE ROS INSTALLATION OR WORKSPACE BEFORE BUILDING RUN_POLICY! This will cause cyclonedds issues, likely because the RMW installed for ROS and the version used by the Go2 SDK are different. For this reason, the actual policy inference code `run_policy.cpp` has been kept separate from any ROS dependencies. For data collection, the `build-and-run.sh` script already records the available robot states into a rosbag, only the actions generated by the policy are not being recorded.

There are two workspaces created by `bootstrap_ros2_ws.sh`, one is for using [https://github.com/inria-paris-robotics-lab/go2_odometry](https://github.com/inria-paris-robotics-lab/go2_odometry) and the other for [https://github.com/Unitree-Go2-Robot/go2_robot](https://github.com/Unitree-Go2-Robot/go2_robot). DO NOT SOURCE BOTH WORKSPACES AT THE SAME TIME OBVIOUSLY AND DO NOT RUN `go2_bringup` at the same time as `go2_odometry`!

Using `go2_robot` is currently not tested because it relies on Fast-LIO2 and LI-INIT for odometry, which is currently not working properly with whe Unitree L1 LIDAR, so you need a supported third party LIDAR. If you do have it, you can use `ros2_ws` to initialize your LIDAR, test FAST-LIO2 to ensure odometry works, then configure `elevation_mapping_cupy` with the published odom frame and lidar topic.

Important: If you run the ROS nodes first, this will cause issues. Unitree Go2 publishes odometry and some other topics only when high level control mode is enabled, and disables them once you want to control the actuators directly. Follow the steps below to set everything up:

1. **In a new terminal without ROS sourced**: Run `build-and-run.sh` inside the docker container as a first step, so that the robot disables the publishers for these topics. Ensure the robot is standing in place or following velocity commands correctly.
2. In a separate terminal, source ROS2, run `colcon build` inside `/app/odom_alternative_ws`, `source /app/odom_alternative_ws/install/setup.bash`, `export ROS_DOMAIN_ID=0` so that go2 topics become visible
3. Ensure you see `/lowstate` under `ros2 topic list`
4. `ros2 launch go2_odometry go2_odometry_switch.launch.py`, open rviz and ensure `/tf` and the `/odom` frame work properly.
5. `python3 rewrite_lidar_frame.py` (Hacky script to adjust lidar data frame for use with the go2_odometry URDF, will need adjustments with LIDAR other than Unitree L1)
6. Inspect `/tf`, pointcloud, robot model, odometry in RViz2 on workstation

## Running CaT (original repo, outdated)

## Installation

- Install Isaac Lab by following the [installation guide](https://isaac-sim.github.io/IsaacLab/v1.4.1/source/setup/installation/index.html).
- Clone the repository separately from the Isaac Lab installation (i.e., outside the `IsaacLab` directory).
- Using a Python interpreter that has Isaac Lab installed, install the library:

```bash
python -m pip install -e exts/cat_envs
```
Navigate to the `/constraints-as-terminations` directory and launch a basic training setup on flat ground:

```bash
python scripts/clean_rl/train.py --task=Isaac-Velocity-CaT-Flat-Solo12-v0 --headless
```

If everything goes well, you will see monitoring statistics in the terminal as the training progresses. At the end, you can check the result with:

```bash
python scripts/clean_rl/play.py --task=Isaac-Velocity-CaT-Flat-Solo12-v0
```

## Citing

Please cite this work as:

```
@inproceedings{chane2024cat,
      title={CaT: Constraints as Terminations for Legged Locomotion Reinforcement Learning},
      author={Elliot Chane-Sane and Pierre-Alexandre Leziart and Thomas Flayols and Olivier Stasse and Philippe Sou{\`e}res and Nicolas Mansard},
      booktitle={IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)},
      year={2024}
}
```
